@using Blazor3D.Models
@using System.Numerics
@inject IJSRuntime JS
@implements IAsyncDisposable

<canvas id="webgpu-canvas"
		class="webgpu-canvas"
		style="height:100%; width:100%;"
		tabindex="0"
		@ref="_canvasRef"
		@onpointerdown="OnPointerDown"
		@onpointermove="OnPointerMove"
		@onpointerup="OnPointerUp"
		@onwheel="OnWheel"
		@onwheel:preventDefault="true"
		@onkeydown="OnKeyDown"
		@onkeyup="OnKeyUp"
		@oncontextmenu:preventDefault="true">
</canvas>

@code {
	/// <summary>
	/// WebGPU rendering options. Pass a configured instance to control grid appearance and camera.
	/// </summary>
	[Parameter]
	public WebGpuGridOptions Options { get; set; } = WebGpuGridOptions.Default;

	/// <summary>
	/// Camera instance for controlling the 3D view.
	/// </summary>
	[Parameter]
	public OrbitCamera? Camera { get; set; }

	private ElementReference _canvasRef;
	private IJSObjectReference? _module;
	private DotNetObjectReference<WebGPUCanvas>? _dotNetRef;
	private bool _ready;
	private string? _error;
	private OrbitCamera _camera = new();
	private bool _isDragging;
	private bool _isPanning;
	private double _lastPointerX;
	private double _lastPointerY;
	private HashSet<string> _pressedKeys = new();
	private System.Threading.Timer? _keyboardMoveTimer;

	public double LatestFrameMs { get; private set; }

	protected override void OnParametersSet()
	{
		// Use provided camera or create default
		if (Camera != null)
		{
			_camera = Camera;
		}
	}

	protected override void OnInitialized()
	{
		// Start keyboard movement timer (60 FPS for smooth movement)
		_keyboardMoveTimer = new System.Threading.Timer(_ => ProcessKeyboardMovement(), null, 0, 16);
	}

	/// <summary>
	/// Adds a mesh to the WebGPU scene for rendering.
	/// </summary>
	public async Task AddMeshAsync(MeshData mesh)
	{
		if (_module is null || !_ready)
		{
			throw new InvalidOperationException("WebGPU is not ready. Wait for initialization.");
		}
		await _module.InvokeVoidAsync("addMesh", mesh.CreateJavascriptData());
	}

	/// <summary>
	/// Adds lines to the WebGPU scene for rendering.
	/// </summary>
	public async Task AddLinesAsync(LineData lines)
	{
		if (_module is null || !_ready)
		{
			throw new InvalidOperationException("WebGPU is not ready. Wait for initialization.");
		}
		await _module.InvokeVoidAsync("addLines", lines.CreateJavascriptData());
	}

	/// <summary>
	/// Removes a mesh from the scene by its ID.
	/// </summary>
	public async Task RemoveMeshAsync(string meshId)
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("removeMesh", meshId);
	}

	/// <summary>
	/// Removes lines from the scene by their ID.
	/// </summary>
	public async Task RemoveLinesAsync(string lineId)
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("removeLines", lineId);
	}

	/// <summary>
	/// Clears all dynamically added meshes from the scene.
	/// </summary>
	public async Task ClearAllMeshesAsync()
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("clearAllMeshes");
	}

	/// <summary>
	/// Clears all dynamically added lines from the scene.
	/// </summary>
	public async Task ClearAllLinesAsync()
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("clearAllLines");
	}

	private void OnPointerDown(PointerEventArgs e)
	{
		if (e.Button == 0) // Left mouse button - rotate
		{
			_isDragging = true;
			_isPanning = false;
			_lastPointerX = e.ClientX;
			_lastPointerY = e.ClientY;
		}
		else if (e.Button == 1) // Middle mouse button - pan
		{
			_isPanning = true;
			_isDragging = false;
			_lastPointerX = e.ClientX;
			_lastPointerY = e.ClientY;
		}
	}

	private async Task OnPointerMove(PointerEventArgs e)
	{
		if (_isDragging)
		{
			var deltaX = e.ClientX - _lastPointerX;
			var deltaY = e.ClientY - _lastPointerY;

			_lastPointerX = e.ClientX;
			_lastPointerY = e.ClientY;

			// Update camera orbit
			_camera.Orbit(deltaX, deltaY);

			// Send updated view matrix to JavaScript
			if (_module != null && _ready)
			{
				await _module.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
			}
		}
		else if (_isPanning)
		{
			var deltaX = e.ClientX - _lastPointerX;
			var deltaY = e.ClientY - _lastPointerY;

			_lastPointerX = e.ClientX;
			_lastPointerY = e.ClientY;

			// Update camera pan (Shift key check)
			_camera.Pan(deltaX, deltaY, e.ShiftKey);

			// Send updated view matrix to JavaScript
			if (_module != null && _ready)
			{
				await _module.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
			}
		}
	}

	private void OnPointerUp(PointerEventArgs e)
	{
		if (e.Button == 0)
		{
			_isDragging = false;
		}
		else if (e.Button == 1)
		{
			_isPanning = false;
		}
	}

	private async Task OnWheel(WheelEventArgs e)
	{
		// Update camera zoom
		_camera.Zoom(e.DeltaY);

		// Send updated view matrix to JavaScript
		if (_module != null && _ready)
		{
			await _module.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
		}
	}

	private void OnKeyDown(KeyboardEventArgs e)
	{
		// Track pressed keys (allow multiple simultaneous keys)
		_pressedKeys.Add(e.Key.ToLower());
	}

	private void OnKeyUp(KeyboardEventArgs e)
	{
		// Remove key from pressed set
		_pressedKeys.Remove(e.Key.ToLower());
	}

	private async void ProcessKeyboardMovement()
	{
		if (_pressedKeys.Count == 0 || _module == null || !_ready) return;

		// Calculate movement direction from pressed keys
		double forward = 0, right = 0, up = 0;
		bool shiftPressed = _pressedKeys.Contains("shift");

		// WASD for horizontal/forward movement
		if (_pressedKeys.Contains("w")) forward += 1;
		if (_pressedKeys.Contains("s")) forward -= 1;
		if (_pressedKeys.Contains("d")) right += 1;
		if (_pressedKeys.Contains("a")) right -= 1;

		// Q/E for vertical movement
		if (_pressedKeys.Contains("q")) up -= 1;
		if (_pressedKeys.Contains("e")) up += 1;

		// Apply movement if any key is pressed
		if (forward != 0 || right != 0 || up != 0)
		{
			_camera.PanDirectional(forward, right, up, shiftPressed);

			// Send updated view matrix to JavaScript
			try
			{
				await _module.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
			}
			catch
			{
				// Ignore exceptions during rapid updates
			}
		}
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (!firstRender) return;

		// One-time initialization: import module and create .NET reference
		_module = await JS.InvokeAsync<IJSObjectReference>("import", "./js/webgpu-canvas.js");
		_dotNetRef = DotNetObjectReference.Create(this);

		// Send initial options and view matrix (this triggers the render loop in JS)
		await SendOptionsToJavaScriptAsync(isInitializing: true);
	}

	protected override async Task OnParametersSetAsync()
	{
		// Only send updates after the module is loaded (after first render)
		await SendOptionsToJavaScriptAsync(isInitializing: false);
	}

	private async Task SendOptionsToJavaScriptAsync(bool isInitializing)
	{
		// Guard: module must be loaded (happens after first render)
		if (_module is null) return;

		if (isInitializing)
		{
			// Pass initial view matrix to JavaScript
			await _module.InvokeVoidAsync("initGPU_Canvas", _dotNetRef, _canvasRef, Options, _camera.GetViewMatrixArray());
		}
		else
		{
			await _module.InvokeVoidAsync("updateGridOptions", Options.ToJavascriptOptions());
		}
	}

	[JSInvokable]
	public Task OnWebGpuReady()
	{
		_ready = true;
		_error = null;
		StateHasChanged();
		return Task.CompletedTask;
	}

	[JSInvokable]
	public Task OnWebGpuError(string message)
	{
		_ready = false;
		_error = message;
		StateHasChanged();
		return Task.CompletedTask;
	}

	[JSInvokable]
	public Task OnFrameMsUpdate(double ms)
	{
		LatestFrameMs = ms;
		// No StateHasChanged to avoid re-render per frame; consumer can bind to events if desired
		return Task.CompletedTask;
	}

	public async ValueTask DisposeAsync()
	{
		// Stop keyboard timer
		_keyboardMoveTimer?.Dispose();

		if (_module is not null)
		{
			try { await _module.InvokeVoidAsync("disposeWebGPU_Canvas"); } catch { /* ignore */ }
			try { await _module.DisposeAsync(); } catch { /* ignore */ }
		}

		_dotNetRef?.Dispose();
	}
}
