@using Blazor3D.Models
@using System.Drawing
@using System.Numerics
@inject IJSRuntime JS
@implements IAsyncDisposable

<canvas id="webgpu-canvas"
		class="webgpu-canvas"
		style="height:100%; width:100%;"
		tabindex="0"
		@ref="_canvasRef"
		@onpointerdown="OnPointerDown"
		@onpointermove="OnPointerMove"
		@onpointerup="OnPointerUp"
		@onwheel="OnWheel"
		@onwheel:preventDefault="true"
		@onkeydown="OnKeyDown"
		@onkeyup="OnKeyUp"
		@oncontextmenu:preventDefault="true">
</canvas>

@code {
	/// <summary>
	/// WebGPU rendering options. Pass a configured instance to control grid appearance and camera.
	/// </summary>
	[Parameter]
	public WebGpuGridOptions Options { get; set; } = WebGpuGridOptions.Default;

	/// <summary>
	/// Camera instance for controlling the 3D view.
	/// </summary>
	[Parameter]
	public OrbitCamera? Camera { get; set; }

	/// <summary>
	/// Event raised when a picking ray is created (e.g., on double-click).
	/// Subscribers can use this ray to perform triangle/primitive intersection tests.
	/// </summary>
	public event Action<Ray>? OnPickingRayCreated;

	private ElementReference _canvasRef;
	private IJSObjectReference? _module;
	private DotNetObjectReference<WebGPUCanvas>? _dotNetRef;
	private bool _ready;
	private string? _error;
	private OrbitCamera _camera = new();
	private bool _isDragging;
	private bool _isPanning;
	private double _lastPointerX;
	private double _lastPointerY;
	private HashSet<string> _pressedKeys = new();
	private System.Threading.Timer? _keyboardMoveTimer;

	// Double-click detection
	private DateTime _lastClickTime = DateTime.MinValue;
	private double _lastClickX;
	private double _lastClickY;
	private const double DoubleClickTimeMs = 300; // Standard double-click time window
	private const double DoubleClickDistancePx = 5; // Maximum distance for double-click

	public double LatestFrameMs { get; private set; }

	protected override void OnParametersSet()
	{
		// Use provided camera or create default
		if (Camera != null)
		{
			_camera = Camera;
		}
	}

	protected override void OnInitialized()
	{
		// Start keyboard movement timer (60 FPS for smooth movement)
		_keyboardMoveTimer = new System.Threading.Timer(_ => ProcessKeyboardMovement(), null, 0, 16);
	}

	/// <summary>
	/// Adds a mesh to the WebGPU scene for rendering.
	/// </summary>
	public async Task AddMeshAsync(MeshData mesh)
	{
		if (_module is null || !_ready)
		{
			throw new InvalidOperationException("WebGPU is not ready. Wait for initialization.");
		}
		await _module.InvokeVoidAsync("addMesh", mesh.CreateJavascriptData());
	}

	/// <summary>
	/// Adds lines to the WebGPU scene for rendering.
	/// </summary>
	public async Task AddLinesAsync(LineData lines)
	{
		if (_module is null || !_ready)
		{
			throw new InvalidOperationException("WebGPU is not ready. Wait for initialization.");
		}
		await _module.InvokeVoidAsync("addLines", lines.CreateJavascriptData());
	}

	/// <summary>
	/// Removes a mesh from the scene by its ID.
	/// </summary>
	public async Task RemoveMeshAsync(string meshId)
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("removeMesh", meshId);
	}

	/// <summary>
	/// Removes lines from the scene by their ID.
	/// </summary>
	public async Task RemoveLinesAsync(string lineId)
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("removeLines", lineId);
	}

	/// <summary>
	/// Clears all dynamically added meshes from the scene.
	/// </summary>
	public async Task ClearAllMeshesAsync()
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("clearAllMeshes");
	}

	/// <summary>
	/// Clears all dynamically added lines from the scene.
	/// </summary>
	public async Task ClearAllLinesAsync()
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("clearAllLines");
	}

	/// <summary>
	/// Adds a text billboard to the WebGPU scene for rendering.
	/// </summary>
	public async Task AddTextBillboardAsync(string id, string text, Vector3 position, Color backgroundColor, Color textColor)
	{
		if (_module is null || !_ready)
		{
			throw new InvalidOperationException("WebGPU is not ready. Wait for initialization.");
		}
		var data = new { id, text, position = new[] { position.X, position.Y, position.Z }, 
		backgroundColor = ColorToJavaScript(backgroundColor).ToArray(), 
		textColor = ColorToJavaScript(textColor).ToArray() };
		await _module.InvokeVoidAsync("addTextBillboard", data);
	}

	/// <summary>
	/// Removes a text billboard from the scene by its ID.
	/// </summary>
	public async Task RemoveTextBillboardAsync(string id)
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("removeTextBillboard", id);
	}

	/// <summary>
	/// Clears all text billboards from the scene.
	/// </summary>
	public async Task ClearAllTextBillboardsAsync()
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("clearAllTextBillboards");
	}

	private void OnPointerDown(PointerEventArgs e)
	{
		var currentTime = DateTime.Now;
		var timeSinceLastClick = (currentTime - _lastClickTime).TotalMilliseconds;
		var distanceFromLastClick = Math.Sqrt(
			Math.Pow(e.ClientX - _lastClickX, 2) + 
			Math.Pow(e.ClientY - _lastClickY, 2));

		// Check for double-click (left mouse button only)
		if (e.Button == 0 && 
			timeSinceLastClick <= DoubleClickTimeMs && 
			distanceFromLastClick <= DoubleClickDistancePx)
		{
			// Double-click detected - handle it here
			OnDoubleClick(e);
			return; // Don't process as single click
		}

		// Update last click info for next potential double-click
		if (e.Button == 0)
		{
			_lastClickTime = currentTime;
			_lastClickX = e.ClientX;
			_lastClickY = e.ClientY;
		}

		if (e.Button == 0) // Left mouse button - rotate
		{
			_isDragging = true;
			_isPanning = false;
			_lastPointerX = e.ClientX;
			_lastPointerY = e.ClientY;
		}
		else if (e.Button == 1) // Middle mouse button - pan
		{
			_isPanning = true;
			_isDragging = false;
			_lastPointerX = e.ClientX;
			_lastPointerY = e.ClientY;
		}
	}

	public static IEnumerable<float> ColorToJavaScript(Color c)
	{
		yield return c.R / 255f;
		yield return c.G / 255f;
		yield return c.B / 255f;
		yield return c.A / 255f;
	}

	private async Task OnDoubleClick(PointerEventArgs e)
	{
		if (_module is null || !_ready)
		{
			return; // WebGPU not ready
		}

		// Get canvas dimensions using JavaScript interop
		var canvasRect = await _module.InvokeAsync<BoundingClientRect>("getBoundingClientRect", _canvasRef);
		var canvasWidth = canvasRect.Width;
		var canvasHeight = canvasRect.Height;

		// Convert mouse position relative to canvas
		var relativeX = e.ClientX - canvasRect.Left;
		var relativeY = e.ClientY - canvasRect.Top;

		// Create picking ray from camera through mouse position
		var pickingRay = _camera.CreateRayFromScreenPoint(relativeX, relativeY, canvasWidth, canvasHeight);

		await AddTextBillboardAsync("myBillboard", "Hello World", pickingRay.Anchor + 5 * pickingRay.Direction, System.Drawing.Color.Blue,
		System.Drawing.Color.White);
		// Raise event for subscribers to handle picking
		OnPickingRayCreated?.Invoke(pickingRay);
	}

	// Helper class for bounding client rect
	private class BoundingClientRect
	{
		public double Left { get; set; }
		public double Top { get; set; }
		public double Width { get; set; }
		public double Height { get; set; }
	}

	private async Task OnPointerMove(PointerEventArgs e)
	{
		if (_isDragging)
		{
			var deltaX = e.ClientX - _lastPointerX;
			var deltaY = e.ClientY - _lastPointerY;

			_lastPointerX = e.ClientX;
			_lastPointerY = e.ClientY;

			// Update camera orbit
			_camera.Orbit(deltaX, deltaY);

			// Send updated view matrix to JavaScript
			if (_module != null && _ready)
			{
				await _module.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
			}
		}
		else if (_isPanning)
		{
			var deltaX = e.ClientX - _lastPointerX;
			var deltaY = e.ClientY - _lastPointerY;

			_lastPointerX = e.ClientX;
			_lastPointerY = e.ClientY;

			// Update camera pan (Shift key check)
			_camera.Pan(deltaX, deltaY, e.ShiftKey);

			// Send updated view matrix to JavaScript
			if (_module != null && _ready)
			{
				await _module.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
			}
		}
	}

	private void OnPointerUp(PointerEventArgs e)
	{
		if (e.Button == 0)
		{
			_isDragging = false;
		}
		else if (e.Button == 1)
		{
			_isPanning = false;
		}
	}

	private async Task OnWheel(WheelEventArgs e)
	{
		// Update camera zoom
		_camera.Zoom(e.DeltaY);

		// Send updated view matrix to JavaScript
		if (_module != null && _ready)
		{
			await _module.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
		}
	}

	private void OnKeyDown(KeyboardEventArgs e)
	{
		// Track pressed keys (allow multiple simultaneous keys)
		_pressedKeys.Add(e.Key.ToLower());
	}

	private void OnKeyUp(KeyboardEventArgs e)
	{
		// Remove key from pressed set
		_pressedKeys.Remove(e.Key.ToLower());
	}

	private async void ProcessKeyboardMovement()
	{
		if (_pressedKeys.Count == 0 || _module == null || !_ready) return;

		// Calculate movement direction from pressed keys
		double forward = 0, right = 0, up = 0;
		bool shiftPressed = _pressedKeys.Contains("shift");

		// WASD for horizontal/forward movement
		if (_pressedKeys.Contains("w")) forward += 1;
		if (_pressedKeys.Contains("s")) forward -= 1;
		if (_pressedKeys.Contains("d")) right += 1;
		if (_pressedKeys.Contains("a")) right -= 1;

		// Q/E for vertical movement
		if (_pressedKeys.Contains("q")) up -= 1;
		if (_pressedKeys.Contains("e")) up += 1;

		// Apply movement if any key is pressed
		if (forward != 0 || right != 0 || up != 0)
		{
			_camera.PanDirectional(forward, right, up, shiftPressed);

			// Send updated view matrix to JavaScript
			try
			{
				await _module.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
			}
			catch
			{
				// Ignore exceptions during rapid updates
			}
		}
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (!firstRender) return;

		// One-time initialization: import module and create .NET reference
		_module = await JS.InvokeAsync<IJSObjectReference>("import", "./js/webgpu-canvas.js");
		_dotNetRef = DotNetObjectReference.Create(this);

		// Send initial options and view matrix (this triggers the render loop in JS)
		await SendOptionsToJavaScriptAsync(isInitializing: true);
	}

	protected override async Task OnParametersSetAsync()
	{
		// Only send updates after the module is loaded (after first render)
		await SendOptionsToJavaScriptAsync(isInitializing: false);
	}

	private async Task SendOptionsToJavaScriptAsync(bool isInitializing)
	{
		// Guard: module must be loaded (happens after first render)
		if (_module is null) return;

		if (isInitializing)
		{
			// Pass initial view matrix to JavaScript
			await _module.InvokeVoidAsync("initGPU_Canvas", _dotNetRef, _canvasRef, Options, _camera.GetViewMatrixArray());
		}
		else
		{
			await _module.InvokeVoidAsync("updateGridOptions", Options.ToJavascriptOptions());
		}
	}

	[JSInvokable]
	public Task OnWebGpuReady()
	{
		_ready = true;
		_error = null;
		StateHasChanged();
		return Task.CompletedTask;
	}

	[JSInvokable]
	public Task OnWebGpuError(string message)
	{
		_ready = false;
		_error = message;
		StateHasChanged();
		return Task.CompletedTask;
	}

	[JSInvokable]
	public Task OnFrameMsUpdate(double ms)
	{
		LatestFrameMs = ms;
		// No StateHasChanged to avoid re-render per frame; consumer can bind to events if desired
		return Task.CompletedTask;
	}

	public async ValueTask DisposeAsync()
	{
		// Stop keyboard timer
		_keyboardMoveTimer?.Dispose();

		if (_module is not null)
		{
			try { await _module.InvokeVoidAsync("disposeWebGPU_Canvas"); } catch { /* ignore */ }
			try { await _module.DisposeAsync(); } catch { /* ignore */ }
		}

		_dotNetRef?.Dispose();
	}

	private void OnCanvasDoubleClick()
	{
		// Handle double-clicks (e.g., reset camera or toggle full screen)
		ResetCamera();
	}

	private void ResetCamera()
	{
		// Reset camera to default position and orientation
		_camera.Reset();

		// Send updated view matrix to JavaScript
		_module?.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
	}
}
