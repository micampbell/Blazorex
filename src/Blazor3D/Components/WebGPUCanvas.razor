@using Blazor3D.Models
@using System.Numerics
@inject IJSRuntime JS
@implements IAsyncDisposable

<canvas id="webgpu-canvas"
		class="webgpu-canvas"
		style="height:100%; width:100%;"
		@ref="_canvasRef"
		@onpointerdown="OnPointerDown"
		@onpointermove="OnPointerMove"
		@onpointerup="OnPointerUp"
		@onwheel="OnWheel"
		@onwheel:preventDefault="true">
</canvas>

@code {
	/// <summary>
	/// WebGPU rendering options. Pass a configured instance to control grid appearance and camera.
	/// </summary>
	[Parameter]
	public WebGpuGridOptions Options { get; set; } = WebGpuGridOptions.Default;

	/// <summary>
	/// Camera instance for controlling the 3D view.
	/// </summary>
	[Parameter]
	public OrbitCamera? Camera { get; set; }

	private ElementReference _canvasRef;
	private IJSObjectReference? _module;
	private DotNetObjectReference<WebGPUCanvas>? _dotNetRef;
	private bool _ready;
	private string? _error;
	private OrbitCamera _camera = new();
	private bool _isDragging;
	private double _lastPointerX;
	private double _lastPointerY;

	public double LatestFrameMs { get; private set; }

	protected override void OnParametersSet()
	{
		// Use provided camera or create default
		if (Camera != null)
		{
			_camera = Camera;
		}
	}

	/// <summary>
	/// Adds a mesh to the WebGPU scene for rendering.
	/// </summary>
	public async Task AddMeshAsync(MeshData mesh)
	{
		if (_module is null || !_ready)
		{
			throw new InvalidOperationException("WebGPU is not ready. Wait for initialization.");
		}
		await _module.InvokeVoidAsync("addMesh", mesh.CreateJavascriptData());
	}

	/// <summary>
	/// Adds a mesh to the WebGPU scene for rendering.
	/// </summary>
	public async Task AddLinesAsync(LineData mesh)
	{
		if (_module is null || !_ready)
		{
			throw new InvalidOperationException("WebGPU is not ready. Wait for initialization.");
		}
		await _module.InvokeVoidAsync("addLines", mesh.CreateJavascriptData());
	}

	/// <summary>
	/// Removes a mesh from the scene by its ID.
	/// </summary>
	public async Task RemoveMeshAsync(string meshId)
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("removeMesh", meshId);
	}

	/// <summary>
	/// Clears all dynamically added meshes from the scene.
	/// </summary>
	public async Task ClearAllMeshesAsync()
	{
		if (_module is null) return;
		await _module.InvokeVoidAsync("clearAllMeshes");
	}

	private void OnPointerDown(PointerEventArgs e)
	{
		if (e.Button == 0) // Left mouse button
		{
			_isDragging = true;
			_lastPointerX = e.ClientX;
			_lastPointerY = e.ClientY;
		}
	}

	private async Task OnPointerMove(PointerEventArgs e)
	{
		if (_isDragging)
		{
			var deltaX = e.ClientX - _lastPointerX;
			var deltaY = e.ClientY - _lastPointerY;

			_lastPointerX = e.ClientX;
			_lastPointerY = e.ClientY;

			// Update camera orbit
			_camera.Orbit(deltaX, deltaY);

			// Send updated view matrix to JavaScript
			if (_module != null && _ready)
			{
				await _module.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
			}
		}
	}

	private void OnPointerUp(PointerEventArgs e)
	{
		if (e.Button == 0)
		{
			_isDragging = false;
		}
	}

	private async Task OnWheel(WheelEventArgs e)
	{
		// Update camera zoom
		_camera.Zoom(e.DeltaY);

		// Send updated view matrix to JavaScript
		if (_module != null && _ready)
		{
			await _module.InvokeVoidAsync("updateViewMatrix", _camera.GetViewMatrixArray());
		}
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (!firstRender) return;

		// One-time initialization: import module and create .NET reference
		_module = await JS.InvokeAsync<IJSObjectReference>("import", "./js/webgpu-canvas.js");
		_dotNetRef = DotNetObjectReference.Create(this);

		// Send initial options and view matrix (this triggers the render loop in JS)
		await SendOptionsToJavaScriptAsync(isInitializing: true);
	}

	protected override async Task OnParametersSetAsync()
	{
		// Only send updates after the module is loaded (after first render)
		await SendOptionsToJavaScriptAsync(isInitializing: false);
	}

	private async Task SendOptionsToJavaScriptAsync(bool isInitializing)
	{
		// Guard: module must be loaded (happens after first render)
		if (_module is null) return;

		if (isInitializing)
		{
			// Pass initial view matrix to JavaScript
			await _module.InvokeVoidAsync("initGPU_Canvas", _dotNetRef, _canvasRef, Options, _camera.GetViewMatrixArray());
		}
		else
		{
			await _module.InvokeVoidAsync("updateGridOptions", Options.ToJavascriptOptions());
		}
	}

	[JSInvokable]
	public Task OnWebGpuReady()
	{
		_ready = true;
		_error = null;
		StateHasChanged();
		return Task.CompletedTask;
	}

	[JSInvokable]
	public Task OnWebGpuError(string message)
	{
		_ready = false;
		_error = message;
		StateHasChanged();
		return Task.CompletedTask;
	}

	[JSInvokable]
	public Task OnFrameMsUpdate(double ms)
	{
		LatestFrameMs = ms;
		// No StateHasChanged to avoid re-render per frame; consumer can bind to events if desired
		return Task.CompletedTask;
	}

	public async ValueTask DisposeAsync()
	{
		if (_module is not null)
		{
			try { await _module.InvokeVoidAsync("disposeWebGPU_Canvas"); } catch { /* ignore */ }
			try { await _module.DisposeAsync(); } catch { /* ignore */ }
		}

		_dotNetRef?.Dispose();
	}
}
